! Use a module to encapsulate the subroutine and the common blocks
module func_module
  implicit none ! Use implicit none to avoid implicit typing
  ! Use parameters to define constants
  integer, parameter :: dp = kind(1.d0) ! Double precision kind
  integer, parameter :: nmax = 10 ! Maximum size of arrays
  integer, parameter :: nvar = 2 ! Number of variables
  integer, parameter :: ncase = 5 ! Number of cases
  
  ! Use derived types to group related variables
  type :: cact_type
    real(dp) :: y1(nmax), y2(nmax), act1(nmax), act2(nmax)
    real(dp) :: dact1(nmax, nmax), dact2(nmax, nmax), pact(nvar, nvar)
  end type cact_type
  
  type :: cmarq_type
    real(dp) :: grad(nvar), xjtj(nvar, nvar)
  end type cmarq_type
  
  type :: cufac_type
    integer :: nk, ng
    real(dp) :: p(nmax, nmax), t
  end type cufac_type
  
  type :: ca_type
    real(dp) :: xc(ncase), ge(ncase, nvar), gc(ncase, nvar)
  end type ca_type
  
  ! Use allocatable arrays for dynamic memory allocation
  real(dp), allocatable :: x(:), f(:) 
  
  ! Use private attribute to hide internal variables
  private :: x, f
  
  ! Use public attribute to expose the subroutine
  public :: func
  
contains

! Use intent attribute to specify the direction of arguments
subroutine func(n, m, ndif, xin, ssq)
  integer, intent(in) :: n, m, ndif ! Input arguments
  real(dp), intent(in) :: xin(nvar) ! Input argument
  real(dp), intent(out) :: ssq ! Output argument
  
  ! Use local variables for temporary storage
  integer :: i, j, k, l, jd
  
  ! Use associate construct to create aliases for common variables
  associate (cact => cact_type(), &
             cmarq => cmarq_type(), &
             cufac => cufac_type(), &
             ca => ca_type())
             
    ! Allocate memory for x and f arrays
    allocate(x(nvar), f(nvar))
    
    jd = 0                                                              
    if (ndif == 1) jd = 4                                                
    cufac%p(1, 2) = xin(1)*300.dp                                                
    cufac%p(2, 1) = xin(2)*300.dp                                                
    call param2                                                       
    ssq = 0.                                                            
    if (ndif /= 0) then ! Use /= operator instead of .NE.                                             
      do i = 1, nvar                                                       
        cmarq%grad(i) = 0.                                                        
        do j = 1, nvar                                                       
          cmarq%xjtj(i, j) = 0.                                                      
        end do                                                        
      end do                                                          
    end if                                                          
    do l = 1, ncase                                                       
      cact%y1(1) = ca%xc(l)                                                       
      cact%y1(2) = 1.dp-ca%xc(l)                                                  
      call unifac(jd, cact%y1, cact%act1, cact%dact1, cact%pact)                                
      do i = 1, nvar                                                       
        f(i) = cact%act1(i)-ca%ge(l, i)                                              
        ca%gc(l, i) = cact%act1(i)                                                   
        ssq = ssq+f(i)*f(i)                                                 
        if (jd /=0 ) then                                               
          do j = 1, nvar                                                       
            cmarq%grad(j) = cmarq%grad(j)+f(i)*cact%pact(i,j)                                    
            do k = 1,nvar                                                       
              cmarq%xjtj(j,k)=cmarq%xjtj(j,k)+cact%pact(i,j)*cact%pact(i,k)
            end do                           
          end do                                                          
        end if                                                          
      end do                                                          
    end do                                                          
    
    ! Deallocate memory for x and f arrays 
    deallocate(x,f)
    
    return
    
   end associate ! End of associate construct
    
end subroutine func

end module func_module

subroutine FUNC(N, M, NDIF, X, SSQ)                                   
IMPLICIT REAL*8(A-H, O-Z)                                          
common/CACT/Y1(10), Y2(10), ACT1(10), ACT2(10), DACT1(10, 10), DACT2(10, 10), PACT(2, 2)                                                     
common/CMARQ/GRAD(2), XJTJ(2, 2)                                    
common/CUFAC/NK, NG, P(10, 10), T                                     
common/CA/XC(5), GE(5, 2), GC(5, 2)                                   
dimension X(2), F(2)                                               
JD = 0                                                              
if (NDIF.EQ.1) JD = 4                                                
P(1, 2) = X(1)*300.D0                                                
P(2, 1) = X(2)*300.D0                                                
call PARAM2                                                       
SSQ = 0.                                                            
if (NDIF.NE.0) then ! Use a logical condition instead of goto 11                                             
    do I = 1, 2                                                       
        GRAD(I) = 0.                                                        
        do J = 1, 2                                                       
            XJTJ(I, J) = 0.                                                      
        end do ! Use end do instead of continue                                                        
    end do                                                          
end if ! Use end if instead of continue                                                          
do L = 1, 5                                                       
    Y1(1) = XC(L)                                                       
    Y1(2) = 1.D0-XC(L)                                                  
    call unifac(JD, Y1, ACT1, DACT1, PACT)                                
    do I = 1, 2                                                       
        F(I) = ACT1(I)-GE(L, I)                                              
        GC(L, I) = ACT1(I)                                                   
        SSQ = SSQ+F(I)*F(I)                                                 
        if (JD.NE.0) then ! Use a logical condition instead of goto 21                                               
            do J = 1, 2                                                       
                GRAD(J) = GRAD(J)+F(I)*PACT(I, J)                                    
                do K = 1, 2                                                       
                    XJTJ(J, K) = XJTJ(J, K)+PACT(I, J)*PACT(I, K)
                end do                           
            end do                                                          
        end if ! Use end if instead of continue                                                          
    end do                                                          
end do                                                          
return                                                            
end

